`include "../00_TB/define.v"
module core #( // DO NOT MODIFY INTERFACE!!!
    parameter DATA_WIDTH = 32,
    parameter ADDR_WIDTH = 32
) ( 
    input i_clk,
    input i_rst_n,

    // Testbench IOs
    output [2:0] o_status, 
    output       o_status_valid,

    // Memory IOs
    output [ADDR_WIDTH-1:0] o_addr,
    output [DATA_WIDTH-1:0] o_wdata,
    output                  o_we,
    input  [DATA_WIDTH-1:0] i_rdata
);

localparam IDLE = 3'b000;
localparam IF = 3'b001;
localparam ID = 3'b010;
localparam EX = 3'b011;
localparam WB = 3'b100;
localparam NPC = 3'b101;
localparam FIN = 3'b110;

// ALU operation codes
localparam SUB    =5'd1;
localparam ADDI   =5'd2;
localparam LW     =5'd3;
localparam SW     =5'd4;
localparam BEQ    =5'd5;
localparam BLT    =5'd6;
localparam JALR   =5'd7;
localparam AUIPC  =5'd8;
localparam SLT    =5'd9;
localparam SRL_OP =5'd10;
localparam FSUB   =5'd11;
localparam FMUL   =5'd12;
localparam FCVTWS =5'd13;
localparam FLW    =5'd14;
localparam FSW    =5'd15;     
localparam FCLASS =5'd16;
localparam EOF    =5'd17;

// ===========================================================================
// SIGNAL DECLARATIONS
// ===========================================================================

// ---------------------------------------------------------------------------
// Controller Signals (FSM and Control)
// ---------------------------------------------------------------------------
reg [2:0] state, state_next;
reg [2:0] o_status_r, o_status_next;
reg o_status_valid_r, o_status_valid_next;
reg o_we_r, o_we_next;
reg [ADDR_WIDTH-1:0] o_addr_r, o_addr_next;
reg [DATA_WIDTH-1:0] o_wdata_r, o_wdata_next;

// Control signals generated by controller
reg pc_write;
reg [1:0] pc_source; // 00: PC+4, 01: branch, 10: jump
reg rf_write_enable;
reg rf_write_is_float;
reg rf_read1_is_float;
reg rf_read2_is_float;
reg [4:0] rf_read_addr1;
reg [4:0] rf_read_addr2;
reg [4:0] rf_write_addr;

// ---------------------------------------------------------------------------
// Datapath Signals
// ---------------------------------------------------------------------------
// Instruction register
reg [DATA_WIDTH-1:0] instruction, instruction_next;

// Instruction fields (decoded from instruction)
reg [4:0] inst_r, inst_next;

// PC datapath
wire [ADDR_WIDTH-1:0] current_pc;
reg [ADDR_WIDTH-1:0] pc_branch_target;
reg [ADDR_WIDTH-1:0] pc_jump_target;
reg [ADDR_WIDTH-1:0] pc_branch_target_r, pc_branch_target_next;
reg [ADDR_WIDTH-1:0] pc_jump_target_r, pc_jump_target_next;

// Register file datapath
wire [DATA_WIDTH-1:0] rf_read_data1;
wire [DATA_WIDTH-1:0] rf_read_data2;
reg [DATA_WIDTH-1:0] rf_write_data;

// ALU datapath
reg [DATA_WIDTH-1:0] alu_operand1;
reg [DATA_WIDTH-1:0] alu_operand2;
wire [DATA_WIDTH-1:0] alu_result;
wire alu_overflow;
wire alu_invalid;

// Execution pipeline registers
reg [DATA_WIDTH-1:0] rs1_value, rs1_value_next;
reg [DATA_WIDTH-1:0] rs2_value, rs2_value_next;
reg [DATA_WIDTH-1:0] exec_result, exec_result_next;
reg branch_taken_r, branch_taken_next;

// Temporary registers for arithmetic operations to avoid width mismatch
reg signed [32:0] temp_addr_calc;       // For address calculations
reg signed [32:0] temp_result_calc;     // For ALU result calculations
reg signed [32:0] temp_branch_calc;     // For branch target calculations

// Memory address ranges (instruction memory: 0-4095, data memory: 4096-8191)
localparam INST_MEM_START = 32'd0;
localparam INST_MEM_END   = 32'd4095;
localparam DATA_MEM_START = 32'd4096;
localparam DATA_MEM_END   = 32'd8191;

// ===========================================================================
// OUTPUT ASSIGNMENTS
// ===========================================================================
assign o_status = o_status_r;
assign o_status_valid = o_status_valid_r;
assign o_we = o_we_r;
assign o_addr = o_addr_r;
assign o_wdata = o_wdata_r;

// ---------------------------------------------------------------------------
// Program Counter
// ---------------------------------------------------------------------------
pc u_pc (
    .i_clk(i_clk),
    .i_rst_n(i_rst_n),
    .i_pc_write(pc_write),
    .i_pc_source(pc_source),
    .i_branch_target(pc_branch_target),
    .i_jump_target(pc_jump_target),
    .o_pc(current_pc)
);

// ---------------------------------------------------------------------------
// Register File (Integer and Floating-point)
// ---------------------------------------------------------------------------
regfile u_regfile (
    .i_clk(i_clk),
    .i_rst_n(i_rst_n),
    .i_write_enable(rf_write_enable),
    .i_write_is_float(rf_write_is_float),
    .i_read1_is_float(rf_read1_is_float),
    .i_read2_is_float(rf_read2_is_float),
    .i_read_addr1(rf_read_addr1),
    .i_read_addr2(rf_read_addr2),
    .i_write_addr(rf_write_addr),
    .i_write_data(rf_write_data),
    .o_read_data1(rf_read_data1),
    .o_read_data2(rf_read_data2)
);

// ---------------------------------------------------------------------------
// Arithmetic Logic Unit (Integer and Floating-point)
// ---------------------------------------------------------------------------
alu u_alu (
    .i_inst(inst_r),
    .i_operand1(alu_operand1),
    .i_operand2(alu_operand2),
    .o_result(alu_result),
    .o_overflow(alu_overflow),
    .o_invalid(alu_invalid)
);

// ===========================================================================
// CONTROLLER (FSM and Control Logic)
// ===========================================================================

// Main FSM and control logic
// Next state logic
always @(*) begin
    case (state)
        IDLE: begin
            state_next = IF;
        end
        IF: begin
            // Always transition to ID after one cycle (memory has 1 cycle latency)
            state_next = ID;
        end
        ID: begin
            // Check if EOF instruction
            if (instruction[6:0] == `OP_EOF) begin
                state_next = FIN;
            end
            else begin
                state_next = EX;
            end
        end
        EX: begin
            // Check for overflow/underflow in integer operations
            if ((inst_r == SUB || inst_r == ADDI) && alu_overflow) begin
                state_next = FIN;
            end
            // Check for invalid results (NaN, Inf) in floating-point operations
            else if ((inst_r == FSUB || inst_r == FMUL || inst_r == FCVTWS) && (alu_overflow || alu_invalid)) begin
                state_next = FIN;
            end
            else begin
                state_next = WB;
            end
        end
        WB: begin
            state_next = NPC;
        end
        NPC: begin
            // Check if finished
            if (inst_r == EOF) begin
                state_next = FIN;
            end
            else begin
                state_next = IDLE;
            end
        end
        FIN: begin
            state_next = FIN;
        end
        default: state_next = IDLE;
    endcase
end

// Control signals and datapath logic
always @(*) begin
    // Default assignments
    o_status_next = o_status_r;
    o_status_valid_next = 1'b0;
    o_we_next = 1'b0;
    o_addr_next = o_addr_r;
    o_wdata_next = o_wdata_r;
    instruction_next = instruction;
    rs1_value_next = rs1_value;
    rs2_value_next = rs2_value;
    exec_result_next = exec_result;
    branch_taken_next = branch_taken_r;
    inst_next = inst_r;
    pc_branch_target_next = pc_branch_target_r;
    pc_jump_target_next = pc_jump_target_r;
    
    // PC control signals
    pc_write = 1'b0;
    pc_source = 2'b00; // Default: PC+4
    
    // Register file control signals
    rf_write_enable = 1'b0;
    rf_write_is_float = 1'b0;
    rf_read1_is_float = 1'b0;
    rf_read2_is_float = 1'b0;
    rf_read_addr1 = 5'd0;
    rf_read_addr2 = 5'd0;
    rf_write_addr = 5'd0;
    rf_write_data = 32'd0;
    
    // ALU control signals
    alu_operand1 = 32'd0;
    alu_operand2 = 32'd0;
    
    // Branch target computation (for later use)
    pc_branch_target = pc_branch_target_r;
    pc_jump_target = pc_jump_target_r;
    
    case (state)
        IDLE: begin
            o_we_next = 1'b0;
            o_addr_next = current_pc;
        end
        
        IF: begin           
            // Latch instruction from memory (memory has 1 cycle latency after address is set)
            instruction_next = i_rdata;
        end
        
        ID: begin
            // Instruction decode: determine instruction type, set status, and preload register values
            // Decode based on opcode and funct fields
            case (instruction[6:0])
                `OP_EOF: begin
                    // EOF instruction
                    o_status_next = `EOF_TYPE;
                    inst_next = EOF;
                end
                
                `OP_SUB: begin
                    // R-type: SUB, SLT, SRL
                    if (instruction[14:12] == `FUNCT3_SUB && instruction[31:25] == `FUNCT7_SUB) begin
                        o_status_next = `R_TYPE;
                        inst_next = SUB;
                        // Preload register values from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read_addr2 = instruction[24:20]; // rs2
                        rf_read1_is_float = 1'b0;
                        rf_read2_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                        rs2_value_next = rf_read_data2;
                    end
                    else if (instruction[14:12] == `FUNCT3_SLT && instruction[31:25] == `FUNCT7_SLT) begin
                        o_status_next = `R_TYPE;
                        inst_next = SLT;
                        // Preload register values from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read_addr2 = instruction[24:20]; // rs2
                        rf_read1_is_float = 1'b0;
                        rf_read2_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                        rs2_value_next = rf_read_data2;
                    end
                    else if (instruction[14:12] == `FUNCT3_SRL && instruction[31:25] == `FUNCT7_SRL) begin
                        o_status_next = `R_TYPE;
                        inst_next = SRL_OP;
                        // Preload register values from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read_addr2 = instruction[24:20]; // rs2
                        rf_read1_is_float = 1'b0;
                        rf_read2_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                        rs2_value_next = rf_read_data2;
                    end
                    else begin
                        o_status_next = `INVALID_TYPE;
                        inst_next = 5'd0;
                    end
                end
                
                `OP_ADDI: begin
                    // I-type: ADDI
                    if (instruction[14:12] == `FUNCT3_ADDI) begin
                        o_status_next = `I_TYPE;
                        inst_next = ADDI;
                        // Preload register value from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read1_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                    end
                    else begin
                        o_status_next = `INVALID_TYPE;
                        inst_next = 5'd0;
                    end
                end
                
                `OP_LW: begin
                    // I-type: LW
                    if (instruction[14:12] == `FUNCT3_LW) begin
                        o_status_next = `I_TYPE;
                        inst_next = LW;
                        // Preload register value from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read1_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                        
                        // Compute memory address directly (don't use ALU to avoid glitches)
                        temp_addr_calc = $signed(rf_read_data1) + $signed({{20{instruction[31]}}, instruction[31:20]});
                        o_addr_next = temp_addr_calc[31:0];
                        o_we_next = 1'b0;
                        exec_result_next = temp_addr_calc[31:0]; // Save address for WB stage
                    end
                    else begin
                        o_status_next = `INVALID_TYPE;
                        inst_next = 5'd0;
                    end
                end
                
                `OP_SW: begin
                    // S-type: SW
                    if (instruction[14:12] == `FUNCT3_SW) begin
                        o_status_next = `S_TYPE;
                        inst_next = SW;
                        // Preload register values from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read_addr2 = instruction[24:20]; // rs2
                        rf_read1_is_float = 1'b0;
                        rf_read2_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                        rs2_value_next = rf_read_data2;
                    end
                    else begin
                        o_status_next = `INVALID_TYPE;
                        inst_next = 5'd0;
                    end
                end
                
                `OP_BEQ: begin
                    // B-type: BEQ or BLT
                    if (instruction[14:12] == `FUNCT3_BEQ) begin
                        o_status_next = `B_TYPE;
                        inst_next = BEQ;
                        // Preload register values from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read_addr2 = instruction[24:20]; // rs2
                        rf_read1_is_float = 1'b0;
                        rf_read2_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                        rs2_value_next = rf_read_data2;
                    end
                    else if (instruction[14:12] == `FUNCT3_BLT) begin
                        o_status_next = `B_TYPE;
                        inst_next = BLT;
                        // Preload register values from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read_addr2 = instruction[24:20]; // rs2
                        rf_read1_is_float = 1'b0;
                        rf_read2_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                        rs2_value_next = rf_read_data2;
                    end
                    else begin
                        o_status_next = `INVALID_TYPE;
                        inst_next = 5'd0;
                    end
                end
                
                `OP_JALR: begin
                    // I-type: JALR
                    if (instruction[14:12] == `FUNCT3_JALR) begin
                        o_status_next = `I_TYPE;
                        inst_next = JALR;
                        // Preload register value from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read1_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                    end
                    else begin
                        o_status_next = `INVALID_TYPE;
                        inst_next = 5'd0;
                    end
                end
                
                `OP_AUIPC: begin
                    // U-type: AUIPC
                    o_status_next = `U_TYPE;
                    inst_next = AUIPC;
                    // AUIPC does not need register values
                end
                
                `OP_FSUB: begin
                    // Floating-point instructions - check funct7
                    if (instruction[31:25] == `FUNCT7_FSUB && instruction[14:12] == `FUNCT3_FSUB) begin
                        o_status_next = `R_TYPE;
                        inst_next = FSUB;
                        // Preload register values from floating-point register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read_addr2 = instruction[24:20]; // rs2
                        rf_read1_is_float = 1'b1;
                        rf_read2_is_float = 1'b1;
                        rs1_value_next = rf_read_data1;
                        rs2_value_next = rf_read_data2;
                    end
                    else if (instruction[31:25] == `FUNCT7_FMUL && instruction[14:12] == `FUNCT3_FMUL) begin
                        o_status_next = `R_TYPE;
                        inst_next = FMUL;
                        // Preload register values from floating-point register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read_addr2 = instruction[24:20]; // rs2
                        rf_read1_is_float = 1'b1;
                        rf_read2_is_float = 1'b1;
                        rs1_value_next = rf_read_data1;
                        rs2_value_next = rf_read_data2;
                    end
                    else if (instruction[31:25] == `FUNCT7_FCVTWS && instruction[14:12] == `FUNCT3_FCVTWS) begin
                        o_status_next = `R_TYPE;
                        inst_next = FCVTWS;
                        // Preload register value from floating-point register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read1_is_float = 1'b1;
                        rs1_value_next = rf_read_data1;
                    end
                    else if (instruction[31:25] == `FUNCT7_FCLASS && instruction[14:12] == `FUNCT3_FCLASS) begin
                        o_status_next = `R_TYPE;
                        inst_next = FCLASS;
                        // Preload register value from floating-point register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read1_is_float = 1'b1;
                        rs1_value_next = rf_read_data1;
                    end
                    else begin
                        o_status_next = `INVALID_TYPE;
                        inst_next = 5'd0;
                    end
                end
                
                `OP_FLW: begin
                    // I-type: FLW
                    if (instruction[14:12] == `FUNCT3_FLW) begin
                        o_status_next = `I_TYPE;
                        inst_next = FLW;
                        // Preload register value from integer register file
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read1_is_float = 1'b0;
                        rs1_value_next = rf_read_data1;
                        
                        // Compute memory address directly (don't use ALU to avoid glitches)
                        temp_addr_calc = $signed(rf_read_data1) + $signed({{20{instruction[31]}}, instruction[31:20]});
                        o_addr_next = temp_addr_calc[31:0];
                        o_we_next = 1'b0;
                        exec_result_next = temp_addr_calc[31:0]; // Save address for WB stage
                    end
                    else begin
                        o_status_next = `INVALID_TYPE;
                        inst_next = 5'd0;
                    end
                end
                
                `OP_FSW: begin
                    // S-type: FSW
                    if (instruction[14:12] == `FUNCT3_FSW) begin
                        o_status_next = `S_TYPE;
                        inst_next = FSW;
                        // Preload register values: rs1 from integer, fs2 from float
                        rf_read_addr1 = instruction[19:15]; // rs1
                        rf_read_addr2 = instruction[24:20]; // fs2
                        rf_read1_is_float = 1'b0;
                        rf_read2_is_float = 1'b1;
                        rs1_value_next = rf_read_data1;
                        rs2_value_next = rf_read_data2;
                    end
                    else begin
                        o_status_next = `INVALID_TYPE;
                        inst_next = 5'd0;
                    end
                end
                
                default: begin
                    o_status_next = `INVALID_TYPE;
                    inst_next = 5'd0;
                end
            endcase
        end
        
        EX: begin
            // Execute stage: Use preloaded register values, compute ALU operations, and evaluate branches
            
            // Extract instruction fields
            case (inst_r)
                SUB, SLT, SRL_OP: begin
                    // R-type integer instructions: rd = rs1 op rs2
                    // Use preloaded register values from rs1_value and rs2_value
                    
                    // Perform ALU operation
                    alu_operand1 = rs1_value;
                    alu_operand2 = rs2_value;
                    exec_result_next = alu_result;
                    
                    // Check for overflow in SUB
                    if (inst_r == SUB && alu_overflow) begin
                        o_status_next = `INVALID_TYPE;
                        o_status_valid_next = 1'b1;
                        ////$display("[ALU] SUB: OVERFLOW DETECTED - x%0d(rs1)=%0d (0x%08h), x%0d(rs2)=%0d (0x%08h)", instruction[19:15], $signed(rs1_value), rs1_value,instruction[24:20], $signed(rs2_value), rs2_value);
                    end
                    else begin
                        // Debug message
                        ////$display("[ALU] %s: x%0d(rs1)=%0d (0x%08h), x%0d(rs2)=%0d (0x%08h) -> x%0d(rd)=%0d (0x%08h)", (inst_r == SUB) ? "SUB" : (inst_r == SLT) ? "SLT" : "SRL_OP",instruction[19:15], $signed(rs1_value), rs1_value,instruction[24:20], $signed(rs2_value), rs2_value,instruction[11:7], $signed(alu_result), alu_result);
                    end
                end
                
                ADDI: begin
                    // I-type: rd = rs1 + sign_extend(imm)
                    // Use preloaded register value from rs1_value
                    
                    // Sign-extend 12-bit immediate
                    alu_operand1 = rs1_value;
                    alu_operand2 = {{20{instruction[31]}}, instruction[31:20]};
                    exec_result_next = alu_result;
                    
                    // Check for overflow in ADDI
                    if (alu_overflow) begin
                        o_status_next = `INVALID_TYPE;
                        o_status_valid_next = 1'b1;
                        
                    end
                    else begin
                        
                    end
                end
                
                LW: begin
                    // I-type load: rd = mem[rs1 + sign_extend(imm)]
                    // Address was already set in ID stage, data is now available in i_rdata
                    // Keep memory address and write enable unchanged
                    // This cycle is used to wait for the data to be loaded from memory
                    // Debug message - show the data being loaded
                    
                end
                
                SW: begin
                    // S-type store: mem[rs1 + sign_extend(imm)] = rs2
                    // Use preloaded register values from rs1_value and rs2_value
                    
                    // Compute memory address directly (don't use ALU to avoid glitches)
                    temp_addr_calc = $signed(rs1_value) + $signed({{20{instruction[31]}}, instruction[31:25], instruction[11:7]});
                    exec_result_next = temp_addr_calc[31:0]; // Store address
                    
                    // Set memory write address and data
                    o_addr_next = temp_addr_calc[31:0];
                    o_wdata_next = rs2_value;
                    o_we_next = 1'b1;
                    
                    // Debug message
                    
                end
                
                BEQ: begin
                    // B-type branch: if (rs1 == rs2) PC = PC + sign_extend(imm)
                    // Use preloaded register values from rs1_value and rs2_value
                    
                    // Evaluate branch condition
                    branch_taken_next = (rs1_value == rs2_value);
                    
                    // Compute branch target: PC + sign_extend(imm << 1)
                    temp_branch_calc = current_pc + {{19{instruction[31]}}, instruction[31], 
                                        instruction[7], instruction[30:25], instruction[11:8], 1'b0};
                    pc_branch_target = temp_branch_calc[31:0];
                    pc_branch_target_next = pc_branch_target;
                    
                    // Debug message
                    // //$display("[ALU] BEQ: x%0d(rs1)=0x%08h (%0d), x%0d(rs2)=0x%08h (%0d) -> %s, target=%0d (0x%08h)", 
                    //          instruction[19:15], rs1_value, $signed(rs1_value),
                    //          instruction[24:20], rs2_value, $signed(rs2_value),
                    //          (rs1_value == rs2_value) ? "TAKEN" : "NOT TAKEN",
                    //          pc_branch_target, pc_branch_target);
                end
                
                BLT: begin
                    // B-type branch: if (rs1 < rs2) PC = PC + sign_extend(imm)
                    // Use preloaded register values from rs1_value and rs2_value
                    
                    // Evaluate branch condition (signed comparison)
                    branch_taken_next = ($signed(rs1_value) < $signed(rs2_value));
                    
                    // Compute branch target: PC + sign_extend(imm << 1)
                    temp_branch_calc = current_pc + {{19{instruction[31]}}, instruction[31], 
                                        instruction[7], instruction[30:25], instruction[11:8], 1'b0};
                    pc_branch_target = temp_branch_calc[31:0];
                    pc_branch_target_next = pc_branch_target;
                    
                    // Debug message
                    // //$display("[ALU] BLT: x%0d(rs1)=0x%08h (%0d), x%0d(rs2)=0x%08h (%0d) -> %s, target=%0d (0x%08h)", 
                    //          instruction[19:15], rs1_value, $signed(rs1_value),
                    //          instruction[24:20], rs2_value, $signed(rs2_value),
                    //          ($signed(rs1_value) < $signed(rs2_value)) ? "TAKEN" : "NOT TAKEN",
                    //          pc_branch_target, pc_branch_target);
                end
                
                JALR: begin
                    // I-type jump: rd = PC + 4, PC = (rs1 + sign_extend(imm)) & ~1
                    // Use preloaded register value from rs1_value
                    
                    // Compute jump target and clear LSB
                    alu_operand1 = rs1_value;
                    alu_operand2 = {{20{instruction[31]}}, instruction[31:20]};
                    pc_jump_target = {alu_result[31:1], 1'b0};
                    pc_jump_target_next = pc_jump_target;
                    
                    // Store return address (PC + 4)
                    exec_result_next = current_pc + 4;
                    
                    // Debug message
                    // //$display("[ALU] JALR: x%0d(rs1)=%0d (0x%08h), imm=%0d -> jump_addr=%0d (0x%08h), x%0d(rd)=%0d (return addr)", 
                    //          instruction[19:15], $signed(rs1_value), rs1_value,
                    //          $signed({{20{instruction[31]}}, instruction[31:20]}),
                    //          {alu_result[31:1], 1'b0}, {alu_result[31:1], 1'b0},
                    //          instruction[11:7], current_pc + 4);
                end
                
                AUIPC: begin
                    // U-type: rd = PC + (imm << 12)
                    // AUIPC does not use register values
                    alu_operand1 = current_pc;
                    alu_operand2 = {instruction[31:12], 12'd0};
                    exec_result_next = alu_result;
                    
                    // Debug message
                    // //$display("[ALU] AUIPC: PC=%0d (0x%08h) + imm=0x%08h -> x%0d(rd)=%0d (0x%08h)", 
                    //          current_pc, current_pc,
                    //          {instruction[31:12], 12'd0},
                    //          instruction[11:7], alu_result, alu_result);
                end
                
                FSUB, FMUL, FCVTWS, FCLASS: begin
                    // Floating-point R-type instructions
                    // Use preloaded register values from rs1_value and rs2_value
                    
                    // Perform floating-point ALU operation
                    alu_operand1 = rs1_value;
                    alu_operand2 = rs2_value;
                    exec_result_next = alu_result;
                    
                    // Check for invalid results (NaN, Inf) in FSUB, FMUL, FCVTWS
                    if ((inst_r == FSUB || inst_r == FMUL || inst_r == FCVTWS) && (alu_overflow || alu_invalid)) begin
                        o_status_next = `INVALID_TYPE;
                        o_status_valid_next = 1'b1;
                    end
                    else begin
                        
                    end
                end
                
                FLW: begin
                    // I-type floating-point load: fd = mem[rs1 + sign_extend(imm)]
                    // Address was already set in ID stage, data is now available in i_rdata
                    // Keep memory address and write enable unchanged
                    
                    // Debug message - show the data being loaded
                    
                end
                
                FSW: begin
                    // S-type floating-point store: mem[rs1 + sign_extend(imm)] = fs2
                    // Use preloaded register values from rs1_value and rs2_value
                    
                    // Compute memory address directly (don't use ALU to avoid glitches)
                    temp_addr_calc = $signed(rs1_value) + $signed({{20{instruction[31]}}, instruction[31:25], instruction[11:7]});
                    exec_result_next = temp_addr_calc[31:0]; // Store address
                    
                    // Set memory write address and data
                    o_addr_next = temp_addr_calc[31:0];
                    o_wdata_next = rs2_value;
                    o_we_next = 1'b1;
                    
                
                end
                
                default: begin
                    // No operation for EOF or invalid instructions
                end
            endcase
        end
        
        WB: begin
            // Write-back stage: Write results to register file and handle memory operations
            o_status_valid_next = 1'b1;
            
            case (inst_r)
                SUB, SLT, SRL_OP, ADDI, AUIPC: begin
                    // Write ALU result to integer register
                    rf_write_enable = 1'b1;
                    rf_write_is_float = 1'b0;
                    rf_write_addr = instruction[11:7]; // rd
                    rf_write_data = exec_result;
                    
                end
                
                LW: begin
                    // Memory operation complete
                    // Register write will happen in NPC stage when i_rdata is stable
                    o_we_next = 1'b0;
                    
                    
                end
                
                SW: begin
                    // Store completes - keep write enable high
                    o_addr_next = exec_result;
                    o_wdata_next = rs2_value;
                    o_we_next = 1'b1;
                    
                    // Debug message for memory store
                    // //$display("[WB] SW: Store to addr=%0d (0x%08h), value=0x%08h (%0d) from x%0d(rs2)", 
                    //          exec_result, exec_result, rs2_value, $signed(rs2_value), instruction[24:20]);
                end
                
                BEQ, BLT: begin
                    // Branch instructions - no register write
                    // Branch is handled in NPC stage
                end
                
                JALR: begin
                    // Write return address (PC + 4) to integer register
                    rf_write_enable = 1'b1;
                    rf_write_is_float = 1'b0;
                    rf_write_addr = instruction[11:7]; // rd
                    rf_write_data = exec_result; // PC + 4
                    // //$display("[WB] JALR: Write x%0d(rd) = %0d (0x%08h) [return addr]", 
                    //          instruction[11:7], exec_result, exec_result);
                end
                
                FSUB, FMUL: begin
                    // Write floating-point result to float register
                    rf_write_enable = 1'b1;
                    rf_write_is_float = 1'b1;
                    rf_write_addr = instruction[11:7]; // fd
                    rf_write_data = exec_result;
                    // //$display("[WB] %s: Write f%0d(rd) = 0x%08h", 
                    //          (inst_r == FSUB) ? "FSUB" : "FMUL",
                    //          instruction[11:7], exec_result);
                end
                
                FCVTWS: begin
                    // Write converted integer result to integer register
                    rf_write_enable = 1'b1;
                    rf_write_is_float = 1'b0;
                    rf_write_addr = instruction[11:7]; // rd
                    rf_write_data = exec_result;
                    // //$display("[WB] FCVTWS: Write x%0d(rd) = %0d (0x%08h)", 
                    //          instruction[11:7], $signed(exec_result), exec_result);
                end
                
                FCLASS: begin
                    // Write classification result to integer register
                    rf_write_enable = 1'b1;
                    rf_write_is_float = 1'b0;
                    rf_write_addr = instruction[11:7]; // rd
                    rf_write_data = exec_result;
                    // //$display("[WB] FCLASS: Write x%0d(rd) = 0x%08h (%0d)", 
                    //          instruction[11:7], exec_result, exec_result);
                end
                
                FLW: begin
                    // Memory operation complete
                    // Register write will happen in NPC stage when i_rdata is stable
                    o_we_next = 1'b0;
                    
                    // Debug message for memory load
                    // //$display("[WB] FLW: Memory read complete from addr=%0d (0x%08h), will write f%0d(rd) in NPC stage", 
                    //          exec_result, exec_result, instruction[11:7]);
                end
                
                FSW: begin
                    // Floating-point store completes - keep write enable high
                    o_addr_next = exec_result;
                    o_wdata_next = rs2_value;
                    o_we_next = 1'b1;
                    
                    // Debug message for memory store
                    // //$display("[WB] FSW: Store to addr=%0d (0x%08h), value=0x%08h from f%0d(rs2)", 
                    //         //  exec_result, exec_result, rs2_value, instruction[24:20]);
                end
                
                default: begin
                    // No register write for EOF or invalid instructions

                end
            endcase
        end
        
        NPC: begin
            // Next PC: Update program counter based on instruction type
            pc_write = 1'b1;
            o_we_next = 1'b0;
            
            case (inst_r)
                LW: begin
                    // Write loaded data to integer register (i_rdata is stable in NPC)
                    rf_write_enable = 1'b1;
                    rf_write_is_float = 1'b0;
                    rf_write_addr = instruction[11:7]; // rd
                    rf_write_data = i_rdata;
                    
                    // Sequential execution: PC = PC + 4
                    pc_source = 2'b00;
                    o_addr_next = current_pc + 4;
                    
                    // Debug message for register write
                    //$display("[NPC] LW: Write x%0d(rd) = 0x%08h (%0d) [loaded from memory]", 
                            //  instruction[11:7], i_rdata, $signed(i_rdata));
                end
                
                FLW: begin
                    // Write loaded data to float register (i_rdata is stable in NPC)
                    rf_write_enable = 1'b1;
                    rf_write_is_float = 1'b1;
                    rf_write_addr = instruction[11:7]; // fd
                    rf_write_data = i_rdata;
                    
                    // Sequential execution: PC = PC + 4
                    pc_source = 2'b00;
                    o_addr_next = current_pc + 4;
                    
                    // Debug message for register write
                    //$display("[NPC] FLW: Write f%0d(rd) = 0x%08h [loaded from memory]", 
                            //  instruction[11:7], i_rdata);
                end
                
                BEQ, BLT: begin
                    // Branch instructions: update PC based on condition
                    if (branch_taken_r) begin
                        pc_source = 2'b01; // Take branch
                        pc_branch_target = pc_branch_target_r;
                        o_addr_next = pc_branch_target_r;
                    end
                    else begin
                        pc_source = 2'b00; // PC + 4
                        o_addr_next = current_pc + 4;
                    end
                end
                
                JALR: begin
                    // Jump: update PC to computed target
                    pc_source = 2'b10; // Jump
                    pc_jump_target = pc_jump_target_r;
                    o_addr_next = pc_jump_target_r;
                end
                
                default: begin
                    // Sequential execution: PC = PC + 4
                    pc_source = 2'b00; // PC + 4
                    o_addr_next = current_pc + 4;
                end
            endcase
        end
        
        FIN: begin
            // Finished - stay in this state and keep status_valid high
            o_status_next = o_status_r;
            o_status_valid_next = 1'b1;  // Keep valid high so testbench can detect completion
        end
        
        default: begin
            o_status_next = 3'd0;
        end
    endcase
end

// ===========================================================================
// SEQUENTIAL LOGIC (State and Pipeline Registers)
// ===========================================================================
always @(posedge i_clk or negedge i_rst_n) begin
    if (!i_rst_n) begin
        state <= IDLE;
        o_status_r <= 0;
        o_status_valid_r <= 0;
        o_we_r <= 0;
        o_addr_r <= 0;
        o_wdata_r <= 0;
        instruction <= 0;
        rs1_value <= 0;
        rs2_value <= 0;
        exec_result <= 0;
        branch_taken_r <= 0;
        inst_r <= 0;
        pc_branch_target_r <= 0;
        pc_jump_target_r <= 0;
    end
    else begin
        state <= state_next;
        o_status_r <= o_status_next;
        o_status_valid_r <= o_status_valid_next;
        o_we_r <= o_we_next;
        o_addr_r <= o_addr_next;
        o_wdata_r <= o_wdata_next;
        instruction <= instruction_next;
        rs1_value <= rs1_value_next;
        rs2_value <= rs2_value_next;
        exec_result <= exec_result_next;
        branch_taken_r <= branch_taken_next;
        inst_r <= inst_next;
        pc_branch_target_r <= pc_branch_target_next;
        pc_jump_target_r <= pc_jump_target_next;

    end
end

// ===========================================================================
// STATE CHANGE MONITOR (for debugging)
// ===========================================================================
// always @(posedge i_clk) begin
//     if (i_rst_n && (state != state_next)) begin
//         case (state_next)
//             IDLE: //$display("[STATE] %0t: %s -> IDLE", $time, 
//                           (state == IF) ? "IF" : (state == ID) ? "ID" : (state == EX) ? "EX" : 
//                           (state == WB) ? "WB" : (state == NPC) ? "NPC" : (state == FIN) ? "FIN" : "IDLE");
//             IF: //$display("[STATE] %0t: %s -> IF [PC=%d]", $time,
//                         (state == IDLE) ? "IDLE" : (state == IF) ? "IF" : (state == ID) ? "ID" : (state == EX) ? "EX" : 
//                         (state == WB) ? "WB" : (state == NPC) ? "NPC" : (state == FIN) ? "FIN" : "UNKNOWN",
//                         current_pc);
//             ID: //$display("[STATE] %0t: %s -> ID [PC=%d, Inst=%b]", $time,
//                         (state == IDLE) ? "IDLE" : (state == IF) ? "IF" : (state == ID) ? "ID" : (state == EX) ? "EX" : 
//                         (state == WB) ? "WB" : (state == NPC) ? "NPC" : (state == FIN) ? "FIN" : "UNKNOWN",
//                         current_pc, i_rdata);
//             EX: //$display("[STATE] %0t: %s -> EX [Inst=%s]", $time,
//                         (state == IDLE) ? "IDLE" : (state == IF) ? "IF" : (state == ID) ? "ID" : (state == EX) ? "EX" : 
//                         (state == WB) ? "WB" : (state == NPC) ? "NPC" : (state == FIN) ? "FIN" : "UNKNOWN",
//                         (inst_next == SUB) ? "SUB" : (inst_next == ADDI) ? "ADDI" : (inst_next == LW) ? "LW" :
//                         (inst_next == SW) ? "SW" : (inst_next == BEQ) ? "BEQ" : (inst_next == BLT) ? "BLT" :
//                         (inst_next == JALR) ? "JALR" : (inst_next == AUIPC) ? "AUIPC" : (inst_next == SLT) ? "SLT" :
//                         (inst_next == SRL_OP) ? "SRL_OP" : (inst_next == FSUB) ? "FSUB" : (inst_next == FMUL) ? "FMUL" :
//                         (inst_next == FCVTWS) ? "FCVTWS" : (inst_next == FLW) ? "FLW" : (inst_next == FSW) ? "FSW" :
//                         (inst_next == FCLASS) ? "FCLASS" : (inst_next == EOF) ? "EOF" : "UNKNOWN");
//             WB: //$display("[STATE] %0t: %s -> WB", $time,
//                         (state == IDLE) ? "IDLE" : (state == IF) ? "IF" : (state == ID) ? "ID" : (state == EX) ? "EX" : 
//                         (state == WB) ? "WB" : (state == NPC) ? "NPC" : (state == FIN) ? "FIN" : "UNKNOWN");
//             NPC: //$display("[STATE] %0t: %s -> NPC", $time,
//                          (state == IDLE) ? "IDLE" : (state == IF) ? "IF" : (state == ID) ? "ID" : (state == EX) ? "EX" : 
//                          (state == WB) ? "WB" : (state == NPC) ? "NPC" : (state == FIN) ? "FIN" : "UNKNOWN");
//             FIN: //$display("[STATE] %0t: %s -> FIN [Program Complete]", $time,
//                          (state == IDLE) ? "IDLE" : (state == IF) ? "IF" : (state == ID) ? "ID" : (state == EX) ? "EX" : 
//                          (state == WB) ? "WB" : (state == NPC) ? "NPC" : (state == FIN) ? "FIN" : "UNKNOWN");
//             default: //$display("[STATE] %0t: UNKNOWN -> UNKNOWN", $time);
//         endcase
//     end
// end

endmodule

// ===========================================================================
// ===========================================================================
// SUB-MODULES
// ===========================================================================
// ===========================================================================

// ---------------------------------------------------------------------------
// Program Counter Module
// ---------------------------------------------------------------------------
module pc#(
    parameter ADDR_WIDTH = 32
)(
    input i_clk,
    input i_rst_n,
    input i_pc_write,
    input [1:0] i_pc_source,          // 00: PC+4, 01: branch, 10: jump
    input [ADDR_WIDTH-1:0] i_branch_target,
    input [ADDR_WIDTH-1:0] i_jump_target,
    output [ADDR_WIDTH-1:0] o_pc
);

reg [ADDR_WIDTH-1:0] pc_r;

assign o_pc = pc_r;

always @(posedge i_clk or negedge i_rst_n) begin
    if (!i_rst_n) begin
        pc_r <= 0;
    end
    else if (i_pc_write) begin
        case (i_pc_source)
            2'b00: pc_r <= pc_r + 4;           // Sequential: PC + 4
            2'b01: pc_r <= i_branch_target;    // Branch taken
            2'b10: pc_r <= i_jump_target;      // Jump
            default: pc_r <= pc_r + 4;
        endcase
    end
end

endmodule

// ---------------------------------------------------------------------------
// Register File Module (Dual Bank: Integer + Floating-point)
// ---------------------------------------------------------------------------
module regfile#(
    parameter DATA_WIDTH = 32
)(
    input i_clk,
    input i_rst_n,
    input i_write_enable,
    input i_write_is_float,        // 1: write to float register, 0: write to int register
    input i_read1_is_float,        // 1: read from float register, 0: read from int register
    input i_read2_is_float,        // 1: read from float register, 0: read from int register
    input [4:0] i_read_addr1,
    input [4:0] i_read_addr2,
    input [4:0] i_write_addr,
    input [DATA_WIDTH-1:0] i_write_data,
    output [DATA_WIDTH-1:0] o_read_data1,
    output [DATA_WIDTH-1:0] o_read_data2
);

// Two separate register banks
reg [DATA_WIDTH-1:0] int_registers [0:31];    // Integer registers (x0-x31)
reg [DATA_WIDTH-1:0] float_registers [0:31];  // Floating-point registers (f0-f31)

// Asynchronous read - select from appropriate register bank
assign o_read_data1 = i_read1_is_float ? float_registers[i_read_addr1] : int_registers[i_read_addr1];
assign o_read_data2 = i_read2_is_float ? float_registers[i_read_addr2] : int_registers[i_read_addr2];

// Synchronous write - write to appropriate register bank
integer i;
always @(posedge i_clk or negedge i_rst_n) begin
    if (!i_rst_n) begin
        for (i = 0; i < 32; i = i + 1) begin
            int_registers[i] <= 0;
            float_registers[i] <= 0;
        end
    end
    else if (i_write_enable) begin
        if (i_write_is_float) begin
            float_registers[i_write_addr] <= i_write_data;
            //$display("[REGFILE] Write f%0d = 0x%08h", i_write_addr, i_write_data);
        end
        else begin
            int_registers[i_write_addr] <= i_write_data;
            //$display("[REGFILE] Write x%0d = 0x%08h (%0d)", i_write_addr, i_write_data, $signed(i_write_data));
        end
    end
end

endmodule

// ---------------------------------------------------------------------------
// Arithmetic Logic Unit (Integer and Floating-point Operations)
// ---------------------------------------------------------------------------
module alu#(
    parameter DATA_WIDTH = 32
)(
    input [4:0] i_inst,                // Instruction type from inst_r
    input [DATA_WIDTH-1:0] i_operand1, // First operand
    input [DATA_WIDTH-1:0] i_operand2, // Second operand
    output reg [DATA_WIDTH-1:0] o_result, // Result
    output reg o_overflow,             // Overflow flag
    output reg o_invalid               // Invalid operation flag
);

// Instruction codes (matches core module localparams)
localparam SUB    = 5'd1;
localparam ADDI   = 5'd2;
localparam LW     = 5'd3;
localparam SW     = 5'd4;
localparam SLT    = 5'd9;
localparam SRL_OP = 5'd10;
localparam JALR   = 5'd7;
localparam AUIPC  = 5'd8;
localparam FSUB   = 5'd11;
localparam FMUL   = 5'd12;
localparam FCVTWS = 5'd13;
localparam FLW    = 5'd14;
localparam FSW    = 5'd15;
localparam FCLASS = 5'd16;

// Floating-point fields
wire sign1, sign2;
wire [7:0] exp1, exp2;
wire [22:0] mant1, mant2;
wire [23:0] mant1_full, mant2_full; // With implicit leading 1

// Extract IEEE 754 fields
assign sign1 = i_operand1[31];
assign exp1 = i_operand1[30:23];
assign mant1 = i_operand1[22:0];
assign mant1_full = (exp1 == 8'd0) ? {1'b0, mant1} : {1'b1, mant1}; // Denormal check

assign sign2 = i_operand2[31];
assign exp2 = i_operand2[30:23];
assign mant2 = i_operand2[22:0];
assign mant2_full = (exp2 == 8'd0) ? {1'b0, mant2} : {1'b1, mant2}; // Denormal check

// Special value detection
wire is_nan1, is_nan2, is_inf1, is_inf2, is_zero1, is_zero2;
assign is_nan1 = (exp1 == 8'hFF) && (mant1 != 23'd0);
assign is_nan2 = (exp2 == 8'hFF) && (mant2 != 23'd0);
assign is_inf1 = (exp1 == 8'hFF) && (mant1 == 23'd0);
assign is_inf2 = (exp2 == 8'hFF) && (mant2 == 23'd0);
assign is_zero1 = (exp1 == 8'd0) && (mant1 == 23'd0);
assign is_zero2 = (exp2 == 8'd0) && (mant2 == 23'd0);

// Internal signals for floating-point operations
reg [47:0] mult_result;
reg [24:0] mant_result;  // 25 bits to detect overflow in bit 24
reg [7:0] exp_result;
reg sign_result;
reg [8:0] exp_sum, exp_diff;
integer shift_amount;
reg [4:0] guard_bit_index, round_bit_index;  // Indices for rounding bits
reg [7:0] normalize_shift_reg;  // 8-bit register for normalize_shift
reg [23:0] sticky_bits_mask;  // For sticky bit calculation
reg [31:0] shift_result_temp;  // Temporary register for shift results
reg signed [8:0] shift_amount_temp;  // 9-bit temp for exp - 127 calculation
reg signed [31:0] shift_amount_full;  // 32-bit for shift_amount assignment
reg [8:0] exp_temp;  // 9-bit temp for exponent calculations
reg signed [32:0] negation_temp;  // 33-bit temp for negation operations
reg [32:0] temp_result_calc;  // 32-bit temp for result calculations

reg sign2_eff;
reg [47:0] mant1_ext, mant2_ext;
reg [47:0] mant_aligned;
reg [48:0] mant_sum_temp;
reg [7:0] exp_larger;
integer normalize_shift;
reg guard_bit, round_bit, sticky_bit;
reg do_add; // 1 for addition, 0 for subtraction
reg swap_operands; // 1 if need to swap for subtraction

always @(*) begin
    // Default values
    o_result = 32'd0;
    o_overflow = 1'b0;
    o_invalid = 1'b0;
    mult_result = 48'd0;
    mant_result = 25'd0;  // Updated to 25 bits
    exp_result = 8'd0;
    sign_result = 1'b0;
    exp_sum = 9'd0;
    exp_diff = 9'd0;
    shift_amount = 0;
    guard_bit_index = 5'd0;
    round_bit_index = 5'd0;
    normalize_shift_reg = 8'd0;
    sticky_bits_mask = 24'd0;
    shift_result_temp = 32'd0;
    shift_amount_temp = 9'd0;
    shift_amount_full = 32'd0;
    exp_temp = 9'd0;
    negation_temp = 33'd0;
    
    
    case (i_inst)
        SUB: begin
            // Signed subtraction
            temp_result_calc = $signed(i_operand1) - $signed(i_operand2);
            o_result = temp_result_calc[31:0];
            // Check for overflow
            if ((i_operand1[31] != i_operand2[31]) && (o_result[31] != i_operand1[31])) begin
                o_overflow = 1'b1;
            end
        end
        
        ADDI, LW, SW, JALR, AUIPC, FLW, FSW: begin
            // Signed addition (for ADDI and address calculations)
            temp_result_calc = $signed(i_operand1) + $signed(i_operand2);
            o_result = temp_result_calc[31:0];
            // Check for overflow
            if ((i_operand1[31] == i_operand2[31]) && (o_result[31] != i_operand1[31])) begin
                o_overflow = 1'b1;
            end
        end
        
        SLT: begin
            // Set less than (signed)
            o_result = ($signed(i_operand1) < $signed(i_operand2)) ? 32'd1 : 32'd0;
        end
        
        SRL_OP: begin
            // Shift right logical
            o_result = i_operand1 >> i_operand2[4:0];
        end
        
        FMUL: begin
            // Floating-point multiplication
            if (is_nan1 || is_nan2) begin
                // NaN * anything = NaN
                o_result = 32'h7FC00000; // Canonical NaN
                o_invalid = 1'b1;
            end
            else if ((is_inf1 && is_zero2) || (is_zero1 && is_inf2)) begin
                // Inf * 0 = NaN (invalid)
                o_result = 32'h7FC00000;
                o_invalid = 1'b1;
            end
            else if (is_inf1 || is_inf2) begin
                // Inf * non-zero = Inf
                sign_result = sign1 ^ sign2;
                o_result = {sign_result, 8'hFF, 23'd0};
            end
            else if (is_zero1 || is_zero2) begin
                // 0 * anything = +0 (per homework spec)
                o_result = 32'd0;
            end
            else begin
                // Normal multiplication
                sign_result = sign1 ^ sign2;
                exp_sum = exp1 + exp2 - 127; // Subtract bias
                mult_result = mant1_full * mant2_full;
                
                // Normalize to get preliminary exponent
                if (mult_result[47]) begin
                    // Result is 1x.xxxx... (normalized with bit 47 set)
                    exp_temp = exp_sum + 1;
                    exp_result = exp_temp[7:0];
                end
                else begin
                    // Result is 01.xxxx... (bit 46 is set)
                    exp_temp = exp_sum;
                    exp_result = exp_temp[7:0];
                end
                
                // Check for overflow/underflow BEFORE rounding (excluding true zero)
                if (exp_result >= 9'd255) begin
                    // Overflow to infinity
                    o_result = {sign_result, 8'hFF, 23'd0};
                    o_overflow = 1'b1;
                end
                else if (exp_result <= 9'd0 && mult_result != 48'd0) begin
                    // Underflow to +0 (underflow does not include true zero)
                    o_result = 32'd0;
                    o_overflow = 1'b1;
                end
                else if (mult_result == 48'd0) begin
                    // True zero result (should not happen in normal case, but be safe)
                    o_result = 32'd0;
                end
                else begin
                    // Normal case: proceed with rounding
                    if (mult_result[47]) begin
                        // Result is 1x.xxxx... (normalized with bit 47 set)
                        // Mantissa we want: mult_result[46:24] (23 bits)
                        // Guard bit: mult_result[23]
                        // Round bit: mult_result[22]
                        // Sticky bit: OR of mult_result[21:0]
                        
                        mant_result = {2'b00, mult_result[46:24]};  // 25 bits with leading 0s
                        
                        // Round-to-nearest-even logic
                        if (mult_result[23]) begin // Guard bit = 1
                            if (mult_result[22] || (|mult_result[21:0])) begin
                                // Round bit or sticky bit is 1: round up
                                mant_result = mant_result + 1;
                                if (mant_result[23]) begin // Overflow in mantissa
                                    mant_result = mant_result >> 1;
                                    exp_result = exp_result + 1;
                                end
                            end
                            else if (mult_result[24]) begin
                                // Exactly halfway (guard=1, round=0, sticky=0): round to even
                                // LSB is mult_result[24], round up only if it's 1
                                mant_result = mant_result + 1;
                                if (mant_result[23]) begin // Overflow in mantissa
                                    mant_result = mant_result >> 1;
                                    exp_result = exp_result + 1;
                                end
                            end
                            // else: LSB is 0 (already even), don't round
                        end
                    end
                    else begin
                        // Result is 01.xxxx... (not normalized, bit 46 is set)
                        // Mantissa we want: mult_result[45:23] (23 bits)
                        // Guard bit: mult_result[22]
                        // Round bit: mult_result[21]
                        // Sticky bit: OR of mult_result[20:0]
                        
                        mant_result = {2'b00, mult_result[45:23]};  // 25 bits with leading 0s
                        
                        // Round-to-nearest-even logic
                        if (mult_result[22]) begin // Guard bit = 1
                            if (mult_result[21] || (|mult_result[20:0])) begin
                                // Round bit or sticky bit is 1: round up
                                mant_result = mant_result + 1;
                                if (mant_result[23]) begin // Overflow in mantissa
                                    mant_result = mant_result >> 1;
                                    exp_result = exp_result + 1;
                                end
                            end
                            else if (mult_result[23]) begin
                                // Exactly halfway (guard=1, round=0, sticky=0): round to even
                                // LSB is mult_result[23], round up only if it's 1
                                mant_result = mant_result + 1;
                                if (mant_result[23]) begin // Overflow in mantissa
                                    mant_result = mant_result >> 1;
                                    exp_result = exp_result + 1;
                                end
                            end
                            // else: LSB is 0 (already even), don't round
                        end
                    end
                    
                    o_result = {sign_result, exp_result[7:0], mant_result[22:0]};
                end
            end
        end
        
        FSUB: begin
            // Floating-point subtraction: op1 - op2
            // Treat as op1 + (-op2) with sign of op2 flipped
            
            // Check for special cases (NaN, Inf) - set invalid flag
            if (is_nan1 || is_nan2) begin
                o_result = 32'h7FC00000; // Canonical NaN
                o_invalid = 1'b1;
            end
            else if (is_inf1 && is_inf2 && (sign1 == sign2)) begin
                // Inf - Inf with same sign = NaN (invalid)
                o_result = 32'h7FC00000;
                o_invalid = 1'b1;
            end
            else if (is_inf1) begin
                // Inf - finite = Inf (same sign)
                o_result = {sign1, 8'hFF, 23'd0};
                o_invalid = 1'b1;
            end
            else if (is_inf2) begin
                // finite - Inf = Inf (opposite sign)
                o_result = {~sign2, 8'hFF, 23'd0};
                o_invalid = 1'b1;
            end
            else if (is_zero1 && is_zero2) begin
                // 0 - 0 = +0
                o_result = 32'd0;
            end
            else if (is_zero1) begin
                // 0 - x = -x (flip sign of operand2)
                o_result = {~sign2, i_operand2[30:0]};
            end
            else if (is_zero2) begin
                // x - 0 = x
                o_result = i_operand1;
            end
            else begin
                // Normal subtraction: op1 - op2 = op1 + (-op2)
                // Use extended precision throughout, round only at the end
                
                // Effective sign of op2 after subtraction (flip it)
                sign2_eff = ~sign2;
                
                // Extend mantissas with high precision (24 extra bits for intermediate precision)
                // Format: [24-bit mantissa with implicit 1][24 extra precision bits]
                mant1_ext = {mant1_full, 24'b0};
                mant2_ext = {mant2_full, 24'b0};
                
                // Determine operation type: if effective signs are same, add; otherwise subtract
                do_add = (sign1 == sign2_eff);
                
                // Align mantissas based on exponent difference
                if (exp1 == exp2) begin
                    exp_larger = exp1;
                    exp_diff = 0;
                    
                    if (do_add) begin
                        // Addition: no swap needed
                        swap_operands = 1'b0;
                        mant_aligned = mant2_ext;
                        sticky_bit = 1'b0;
                    end
                    else begin
                        // Subtraction: ensure op1 >= op2 in magnitude
                        if (mant1_full >= mant2_full) begin
                            swap_operands = 1'b0;
                            mant_aligned = mant2_ext;
                        end
                        else begin
                            swap_operands = 1'b1;
                            mant_aligned = mant1_ext;
                            mant1_ext = mant2_ext;
                        end
                        sticky_bit = 1'b0;
                    end
                end
                else if (exp1 > exp2) begin
                    exp_larger = exp1;
                    exp_diff = exp1 - exp2;
                    swap_operands = 1'b0;
                    
                    // Shift mant2 right by exp_diff
                    if (exp_diff >= 48) begin
                        mant_aligned = 48'd0;
                        sticky_bit = (mant2_ext != 0);
                    end
                    else begin
                        mant_aligned = mant2_ext >> exp_diff;
                        sticky_bit = |(mant2_ext & ((48'd1 << exp_diff) - 48'd1));
                    end
                end
                else begin
                    exp_larger = exp2;
                    exp_diff = exp2 - exp1;
                    swap_operands = 1'b1; // op2 is larger exponent
                    
                    // Shift mant1 right by exp_diff
                    if (exp_diff >= 48) begin
                        mant_aligned = 48'd0;
                        sticky_bit = (mant1_ext != 0);
                    end
                    else begin
                        mant_aligned = mant1_ext >> exp_diff;
                        sticky_bit = |(mant1_ext & ((48'd1 << exp_diff) - 48'd1));
                    end
                    
                    // Swap operands for computation
                    mant1_ext = mant2_ext;
                end
                
                // Perform addition or subtraction with full precision
                if (do_add) begin
                    // Addition
                    mant_sum_temp = {1'b0, mant1_ext} + {1'b0, mant_aligned};
                    sign_result = swap_operands ? sign2_eff : sign1;
                end
                else begin
                    // Subtraction (mant1_ext is always >= mant_aligned here)
                    mant_sum_temp = {1'b0, mant1_ext} - {1'b0, mant_aligned};
                    sign_result = swap_operands ? sign2_eff : sign1;
                end
                
                exp_result = exp_larger;
                
                // Normalize (no rounding yet, just shifting)
                if (mant_sum_temp == 49'd0) begin
                    o_result = 32'd0;
                end
                else begin
                    // Find the position of the leading 1 bit
                    // Count how many bits to shift left to get bit 47 as the leading 1
                    normalize_shift = 0;
                    
                    if (mant_sum_temp[48]) begin
                        // Overflow bit set: need to shift right
                        normalize_shift = -1; // Special value indicating right shift
                    end
                    else if (!mant_sum_temp[47]) begin
                        // Need to shift left - count leading zeros from bit 47 down
                        if (mant_sum_temp[46]) normalize_shift = 1;
                        else if (mant_sum_temp[45]) normalize_shift = 2;
                        else if (mant_sum_temp[44]) normalize_shift = 3;
                        else if (mant_sum_temp[43]) normalize_shift = 4;
                        else if (mant_sum_temp[42]) normalize_shift = 5;
                        else if (mant_sum_temp[41]) normalize_shift = 6;
                        else if (mant_sum_temp[40]) normalize_shift = 7;
                        else if (mant_sum_temp[39]) normalize_shift = 8;
                        else if (mant_sum_temp[38]) normalize_shift = 9;
                        else if (mant_sum_temp[37]) normalize_shift = 10;
                        else if (mant_sum_temp[36]) normalize_shift = 11;
                        else if (mant_sum_temp[35]) normalize_shift = 12;
                        else if (mant_sum_temp[34]) normalize_shift = 13;
                        else if (mant_sum_temp[33]) normalize_shift = 14;
                        else if (mant_sum_temp[32]) normalize_shift = 15;
                        else if (mant_sum_temp[31]) normalize_shift = 16;
                        else if (mant_sum_temp[30]) normalize_shift = 17;
                        else if (mant_sum_temp[29]) normalize_shift = 18;
                        else if (mant_sum_temp[28]) normalize_shift = 19;
                        else if (mant_sum_temp[27]) normalize_shift = 20;
                        else if (mant_sum_temp[26]) normalize_shift = 21;
                        else if (mant_sum_temp[25]) normalize_shift = 22;
                        else if (mant_sum_temp[24]) normalize_shift = 23;
                        else if (mant_sum_temp[23]) normalize_shift = 24;
                        else if (mant_sum_temp[22]) normalize_shift = 25;
                        else if (mant_sum_temp[21]) normalize_shift = 26;
                        else if (mant_sum_temp[20]) normalize_shift = 27;
                        else if (mant_sum_temp[19]) normalize_shift = 28;
                        else if (mant_sum_temp[18]) normalize_shift = 29;
                        else if (mant_sum_temp[17]) normalize_shift = 30;
                        else if (mant_sum_temp[16]) normalize_shift = 31;
                        else if (mant_sum_temp[15]) normalize_shift = 32;
                        else if (mant_sum_temp[14]) normalize_shift = 33;
                        else if (mant_sum_temp[13]) normalize_shift = 34;
                        else if (mant_sum_temp[12]) normalize_shift = 35;
                        else if (mant_sum_temp[11]) normalize_shift = 36;
                        else if (mant_sum_temp[10]) normalize_shift = 37;
                        else if (mant_sum_temp[9]) normalize_shift = 38;
                        else if (mant_sum_temp[8]) normalize_shift = 39;
                        else if (mant_sum_temp[7]) normalize_shift = 40;
                        else if (mant_sum_temp[6]) normalize_shift = 41;
                        else if (mant_sum_temp[5]) normalize_shift = 42;
                        else if (mant_sum_temp[4]) normalize_shift = 43;
                        else if (mant_sum_temp[3]) normalize_shift = 44;
                        else if (mant_sum_temp[2]) normalize_shift = 45;
                        else if (mant_sum_temp[1]) normalize_shift = 46;
                        else if (mant_sum_temp[0]) normalize_shift = 47;
                        else normalize_shift = 48; // All zeros case, handled above
                    end
                    // else normalize_shift = 0 (already normalized, bit 47 is set)
                    
                    // Perform normalization shift
                    if (normalize_shift == -1) begin
                        // Right shift by 1
                        mant_sum_temp = mant_sum_temp >> 1;
                        exp_result = exp_result + 1;
                    end
                    else if (normalize_shift > 0) begin
                        // Left shift
                        mant_sum_temp = mant_sum_temp << normalize_shift;
                        normalize_shift_reg = normalize_shift;
                        exp_temp = exp_result - normalize_shift_reg;
                        exp_result = exp_temp[7:0];
                    end
                    
                    // Check for overflow/underflow BEFORE rounding (excluding true zero)
                    if (exp_result >= 9'd255) begin
                        // Overflow to infinity
                        o_result = {sign_result, 8'hFF, 23'd0};
                        o_overflow = 1'b1;
                    end
                    else if (exp_result <= 9'd0 && mant_sum_temp != 49'd0) begin
                        // Underflow to +0 (underflow does not include true zero)
                        o_result = 32'd0;
                        o_overflow = 1'b1;
                    end
                    else if (mant_sum_temp == 49'd0) begin
                        // True zero result
                        o_result = 32'd0;
                    end
                    else begin
                        // Normal case: proceed with rounding
                        // After normalization, bit 47 should be the leading 1
                        // Extract: mant_sum_temp[47:24] = 24-bit mantissa
                        // Guard bit = mant_sum_temp[23]
                        // Round bit = mant_sum_temp[22]
                        // Sticky bits = mant_sum_temp[21:0]
                        
                        guard_bit = mant_sum_temp[23];
                        round_bit = mant_sum_temp[22];
                        sticky_bit = sticky_bit | (|mant_sum_temp[21:0]);
                        mant_result = {1'b0, mant_sum_temp[47:24]};  // 25 bits
                        
                        // Round to nearest, ties to even
                        if (guard_bit) begin
                            if (round_bit || sticky_bit || mant_result[0]) begin
                                // Round up
                                mant_result = mant_result + 1;
                                if (mant_result[24]) begin
                                    // Rounding caused overflow
                                    mant_result = mant_result >> 1;
                                    exp_result = exp_result + 1;
                                end
                            end
                        end
                        
                        o_result = {sign_result, exp_result[7:0], mant_result[22:0]};
                    end
                end
            end
        end
        
        FCVTWS: begin
            // Convert float to signed integer (FCVT.W.S)
            if (is_nan1) begin
                // NaN -> max int (implementation defined)
                o_result = 32'h7FFFFFFF;
                o_invalid = 1'b1;
            end
            else if (is_inf1) begin
                // Inf -> max/min int based on sign
                o_result = sign1 ? 32'h80000000 : 32'h7FFFFFFF;
                o_invalid = 1'b1;
            end
            else if (is_zero1) begin
                // 0 -> 0
                o_result = 32'd0;
            end
            else begin
                // Normal conversion
                if (exp1 < 127) begin
                    // Fractional number -> 0
                    o_result = 32'd0;
                end
                else if (exp1 >= 158) begin
                    // Too large for 32-bit int
                    o_result = sign1 ? 32'h80000000 : 32'h7FFFFFFF;
                    o_overflow = 1'b1;
                end
                else begin
                    // Normal conversion with round-to-nearest-even
                    shift_amount_temp = exp1 - 127;
                    shift_amount_full = {{23{shift_amount_temp[8]}}, shift_amount_temp}; // Sign-extend 9-bit to 32-bit
                    shift_amount = shift_amount_full;
                    
                    if (shift_amount >= 31) begin
                        // Value too large, but not caught by exp check (shouldn't happen)
                        o_result = sign1 ? 32'h80000000 : 32'h7FFFFFFF;
                        o_overflow = 1'b1;
                    end
                    else if (shift_amount >= 23) begin
                        // All mantissa bits are in integer part, no fractional bits
                        shift_result_temp = {8'd0, mant1_full} << (shift_amount - 23);
                        o_result = shift_result_temp;
                        
                        // Check for overflow before applying sign
                        if (!sign1 && (o_result > 32'h7FFFFFFF || o_result[31])) begin
                            // Positive value exceeds INT_MAX
                            o_result = 32'h7FFFFFFF;
                            o_overflow = 1'b1;
                        end
                        else if (sign1) begin
                            // For negative values, check if magnitude exceeds INT_MIN
                            if (o_result > 32'h80000000) begin
                                // Magnitude too large for INT_MIN
                                o_result = 32'h80000000;
                                o_overflow = 1'b1;
                            end
                            else begin
                                negation_temp = -$signed(o_result);
                                o_result = negation_temp[31:0];
                            end
                        end
                    end
                    else begin
                        // Some mantissa bits are fractional - need rounding
                        // Integer part: upper bits after shift
                        // Fractional part: lower bits after shift
                        
                        shift_result_temp = {8'd0, mant1_full} >> (23 - shift_amount);
                        o_result = shift_result_temp;
                        
                        // Round-to-nearest-even
                        // Guard bit: bit at position (22 - shift_amount)
                        // Round bit: bit at position (21 - shift_amount)
                        // Sticky bits: all bits below round bit
                        
                        guard_bit_index = 22 - shift_amount;
                        round_bit_index = 21 - shift_amount;
                        
                        if (shift_amount <= 22) begin
                            // Check guard bit (the bit just below the result)
                            if (mant1_full[guard_bit_index]) begin
                                // Guard bit is 1
                                if (shift_amount <= 21) begin
                                    // Check round and sticky bits
                                    sticky_bits_mask = (1 << (21 - shift_amount)) - 1;
                                    if (mant1_full[round_bit_index] | (|(mant1_full & sticky_bits_mask))) begin
                                        // Round or sticky bit is 1: round up
                                        o_result = o_result + 1;
                                    end
                                    else if (o_result[0]) begin
                                        // Exactly halfway and LSB is 1: round up to make even
                                        o_result = o_result + 1;
                                    end
                                end
                                else begin
                                    // shift_amount == 22: only guard bit exists
                                    if (o_result[0]) begin
                                        // LSB is 1: round to even
                                        o_result = o_result + 1;
                                    end
                                end
                            end
                        end
                        
                        // Apply sign
                        if (sign1) begin
                            negation_temp = -$signed(o_result);
                            o_result = negation_temp[31:0];
                        end
                        
                        // Check for overflow after rounding
                        if (!sign1 && (o_result[31])) begin
                            // Positive overflow
                            o_result = 32'h7FFFFFFF;
                            o_overflow = 1'b1;
                        end
                        else if (sign1 && (o_result == 32'h80000000)) begin
                            // This is valid minimum integer, not overflow
                        end
                        else if (sign1 && (!o_result[31]) && (o_result != 0)) begin
                            // Negative overflow (shouldn't happen with proper range check)
                            o_result = 32'h80000000;
                            o_overflow = 1'b1;
                        end
                    end
                end
            end
        end
        
        FCLASS: begin
            // Classify floating-point number
            // Returns a 10-bit mask in least significant bits
            if (is_nan1) begin
                if (i_operand1[22]) begin
                    o_result = 32'd512; // Quiet NaN (bit 9)
                end
                else begin
                    o_result = 32'd256; // Signaling NaN (bit 8)
                end
            end
            else if (is_inf1) begin
                if (sign1) begin
                    o_result = 32'd1; // Negative infinity (bit 0)
                end
                else begin
                    o_result = 32'd128; // Positive infinity (bit 7)
                end
            end
            else if (is_zero1) begin
                if (sign1) begin
                    o_result = 32'd8; // Negative zero (bit 3)
                end
                else begin
                    o_result = 32'd16; // Positive zero (bit 4)
                end
            end
            else if (exp1 == 8'd0) begin
                // Denormal (subnormal) number
                if (sign1) begin
                    o_result = 32'd4; // Negative subnormal (bit 2)
                end
                else begin
                    o_result = 32'd32; // Positive subnormal (bit 5)
                end
            end
            else begin
                // Normal number
                if (sign1) begin
                    o_result = 32'd2; // Negative normal (bit 1)
                end
                else begin
                    o_result = 32'd64; // Positive normal (bit 6)
                end
            end
        end
        
        default: begin
            o_result = 32'd0;
            o_invalid = 1'b1;
        end
    endcase
end

endmodule
